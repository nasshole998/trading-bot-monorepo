package graph

import (
	"context"
	"fmt"
	"log"
	"time"

	"google.golang.org/protobuf/types/known/timestamppb"

	pb "trading-bot-monorepo/proto/backtester"
	"trading-bot-monorepo/ui-sveltekit-typescript/bff-go/pkg/backtesterclient"
)

// This file will be automatically regenerated based on schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
//
// It serves as a template for your resolvers.

// Resolver is the root resolver struct. It holds dependencies like gRPC clients.
type Resolver struct {
	BacktesterClient *backtesterclient.Client
	// Add other backend clients here (Risk Management, Data Ingestion, Infrastructure)
}

// NewResolver creates a new root resolver instance
func NewResolver(backtesterClient *backtesterclient.Client) *Resolver {
	return &Resolver{
		BacktesterClient: backtesterClient,
	}
}


// Query returns the QueryResolver implementation.
// This method is generated by gqlgen.
func (r *Resolver) Query() QueryResolver {
	return &queryResolver{r}
}

type queryResolver struct{ *Resolver }


// listBacktests resolves the listBacktests query
func (r *queryResolver) ListBacktests(ctx context.Context) ([]*Backtest, error) {
	if r.BacktesterClient == nil {
		log.Println("Backtester client is not initialized")
		return nil, fmt.Errorf("backtester client not available")
	}

	summaries, err := r.BacktesterClient.ListBacktests(ctx)
	if err != nil {
		log.Printf("Error calling ListBacktests: %v", err)
		return nil, fmt.Errorf("failed to fetch backtest summaries: %w", err)
	}

	var backtests []*Backtest
	for _, summary := range summaries {
		// Map summary fields, details fields will be resolved later if requested
		backtests = append(backtests, &Backtest{
			ID:           summary.Id,
			StrategyName: summary.StrategyName,
			Symbol:       summary.Symbol,
			StartTime:    formatTimestamp(summary.StartTime),
			EndTime:      formatTimestamp(summary.EndTime),
			Success:      summary.Success,
			ErrorMessage: summary.ErrorMessage,
			// Map summary metrics if added to schema and proto summary
			// TotalProfit: summary.TotalProfit, // Example
		})
	}

	log.Printf("Resolved listBacktests query, returning %d backtests", len(backtests))
	return backtests, nil
}

// **NEW:** backtest resolves the backtest(id: ID!) query
func (r *queryResolver) Backtest(ctx context.Context, id string) (*Backtest, error) {
	if r.BacktesterClient == nil {
		log.Println("Backtester client is not initialized")
		return nil, fmt.Errorf("backtester client not available")
	}

	// Call the Backtester gRPC service to get detailed results
	result, err := r.BacktesterClient.GetBacktestDetails(ctx, id)
	if err != nil {
		log.Printf("Error calling GetBacktestResult for ID %s: %v", id, err)
		return nil, fmt.Errorf("failed to fetch backtest details for ID %s: %w", id, err)
	}

	// Map protobuf BacktestResult to GraphQL Backtest type
	// The Backtest type now includes nested types (Metrics, Trades, EquityCurve)
	// We'll map them here.

	// Map BacktestMetrics proto to GraphQL BacktestMetrics type
	metrics := mapBacktestMetrics(result.GetMetrics())

	// Map TradeResult protos to GraphQL Trade types
	trades := mapTradeResults(result.GetTrades())

	// Map EquityPoint protos to GraphQL EquityPoint types
	equityCurve := mapEquityPoints(result.GetEquityCurve())


	// Create the main GraphQL Backtest object, mapping summary fields and including the mapped details
	backtest := &Backtest{
		ID:           result.GetSummary().GetId(),
		StrategyName: result.GetSummary().GetStrategyName(),
		Symbol:       result.GetSummary().GetSymbol(),
		StartTime:    formatTimestamp(result.GetSummary().GetStartTime()),
		EndTime:      formatTimestamp(result.GetSummary().GetEndTime()),
		Success:      result.GetSummary().GetSuccess(),
		ErrorMessage: result.GetSummary().GetErrorMessage(),
		Metrics:      metrics,
		Trades:       trades,
		EquityCurve:  equityCurve,
	}

	log.Printf("Resolved backtest query for ID %s", id)
	return backtest, nil
}


// Helper function to format protobuf Timestamp to string
func formatTimestamp(ts *timestamppb.Timestamp) string {
	if ts == nil {
		return ""
	}
	return ts.AsTime().Format(time.RFC3339)
}

// **NEW:** Helper to map protobuf BacktestMetrics to GraphQL BacktestMetrics
func mapBacktestMetrics(pbMetrics *pb.BacktestMetrics) *BacktestMetrics {
	if pbMetrics == nil {
		return nil
	}
	return &BacktestMetrics{
		TotalProfit:           pbMetrics.TotalProfit,
		TotalFees:             pbMetrics.TotalFees,
		SharpeRatio:           pbMetrics.SharpeRatio,
		SortinoRatio:          pbMetrics.SortinoRatio,
		MaxDrawdown:           pbMetrics.MaxDrawdown,
		WinRate:               pbMetrics.WinRate,
		LossRate:              pbMetrics.LossRate,
		ProfitFactor:          pbMetrics.ProfitFactor,
		AverageProfitPerTrade: pbMetrics.AverageProfitPerTrade,
		AverageLossPerTrade:   pbMetrics.AverageLossPerTrade,
		LargestWinningTrade:   pbMetrics.LargestWinningTrade,
		LargestLosingTrade:    pbMetrics.LargestLosingTrade,
		TotalTrades:           int(pbMetrics.TotalTrades), // Cast int32 to int
		WinningTrades:         int(pbMetrics.WinningTrades),
		LosingTrades:          int(pbMetrics.LosingTrades),
	}
}

// **NEW:** Helper to map protobuf TradeResult list to GraphQL Trade list
func mapTradeResults(pbTrades []*pb.TradeResult) []*Trade {
	if pbTrades == nil {
		return nil
	}
	trades := make([]*Trade, len(pbTrades))
	for i, pbTrade := range pbTrades {
		trades[i] = &Trade{
			ID:          pbTrade.Id,
			Symbol:      pbTrade.Symbol,
			Side:        mapOrderSide(pbTrade.Side), // Map protobuf enum to GraphQL enum
			Quantity:    pbTrade.Quantity,
			Price:       pbTrade.Price,
			Timestamp:   formatTimestamp(pbTrade.Timestamp),
			Fee:         pbTrade.Fee,
			FeeAsset:    pbTrade.FeeAsset,
			RealizedPnl: &pbTrade.RealizedPnl, // Use pointer for optional field
		}
	}
	return trades
}

// **NEW:** Helper to map protobuf EquityPoint list to GraphQL EquityPoint list
func mapEquityPoints(pbPoints []*pb.EquityPoint) []*EquityPoint {
	if pbPoints == nil {
		return nil
	}
	points := make([]*EquityPoint, len(pbPoints))
	for i, pbPoint := range pbPoints {
		points[i] = &EquityPoint{
			Timestamp: formatTimestamp(pbPoint.Timestamp),
			Equity:    pbPoint.Equity,
		}
	}
	return points
}

// **NEW:** Helper to map protobuf OrderSide enum to GraphQL OrderSide enum
func mapOrderSide(pbSide pb.OrderSide) OrderSide {
	switch pbSide {
	case pb.OrderSide_BUY:
		return OrderSideBuy
	case pb.OrderSide_SELL:
		return OrderSideSell
	default:
		return OrderSideUnknownOrderSide // Map unknown values
	}
}

// Note: You need to re-run `gqlgen generate` after updating schema.graphqls
// and re-run `protoc` after updating backtester.proto