syntax = "proto3";

package market_data;

import "google/protobuf/timestamp.proto";

// Enum for trade side
enum OrderSide {
  ORDER_SIDE_UNSPECIFIED = 0;
  ORDER_SIDE_BUY = 1;
  ORDER_SIDE_SELL = 2;
}

// Enum for order type
enum OrderType {
  ORDER_TYPE_UNSPECIFIED = 0;
  ORDER_TYPE_MARKET = 1; // Execute at best available price
  ORDER_TYPE_LIMIT = 2;  // Execute at a specified price or better
  // Add other types like STOP, STOP_LIMIT, etc. as needed
}

// Enum for order status
enum OrderStatus {
  ORDER_STATUS_UNSPECIFIED = 0;
  ORDER_STATUS_NEW = 1; // Order created but not yet acknowledged by exchange
  ORDER_STATUS_ACKNOWLEDGED = 2; // Order acknowledged by exchange
  ORDER_STATUS_PARTIALLY_FILLED = 3; // Order partially filled
  ORDER_STATUS_FILLED = 4; // Order fully filled
  ORDER_STATUS_CANCELED = 5; // Order canceled
  ORDER_STATUS_REJECTED = 6; // Order rejected by exchange or system
  ORDER_STATUS_EXPIRED = 7; // Order expired
  ORDER_STATUS_PENDING_CANCEL = 8; // Order cancellation requested
  ORDER_STATUS_PENDING_REPLACE = 9; // Order replacement requested
}


// Market data events stream from ingestion service
service MarketDataService {
  // Client-streaming RPC to receive real-time market data events from the ingestion service.
  // The client (Ingestion Service) streams MarketDataEvent messages to the server (other components).
  rpc StreamMarketData(stream MarketDataEvent) returns (StreamMarketDataResponse);

  // RPC for strategy engine to send trade orders for execution.
  // This RPC is called by the Strategy Engine (client) on the Data Ingestion Service (server).
  rpc ExecuteOrder(OrderRequest) returns (OrderResponse);

  // Server-streaming RPC for order status updates from the ingestion service.
  // Strategy Engine (client) subscribes here to get updates on its placed orders.
  rpc SubscribeToOrderUpdates(OrderUpdateRequest) returns (stream OrderUpdate);
}

message MarketDataEvent {
  // Use oneof to represent different types of market data
  oneof event_type {
    Trade trade = 1;
    Quote quote = 2;
    OrderBookUpdate order_book_update = 3;
    # Add other event types like Candlestick, FundingRate, etc.
  }
}

message Trade {
  string exchange = 1;         // e.g., "binance"
  string symbol = 2;           // e.g., "btc_usdt" (normalized)
  string trade_id = 3;         // Exchange's trade ID
  string price = 4;            // Price of the trade (string for precision)
  string quantity = 5;         // Quantity traded (string for precision)
  google.protobuf.Timestamp timestamp = 6; // Timestamp of the trade
  OrderSide side = 7;          // BUY or SELL side of the aggressor
}

message Quote {
  string exchange = 1;         // e.g., "binance"
  string symbol = 2;           // e.g., "btc_usdt" (normalized)
  string bid_price = 3;        // Best bid price (string)
  string bid_quantity = 4;     // Quantity available at best bid (string)
  string ask_price = 5;        // Best ask price (string)
  string ask_quantity = 6;     // Quantity available at best ask (string)
  google.protobuf.Timestamp timestamp = 7; // Timestamp of the quote
}

message OrderBookUpdate {
  string exchange = 1;          // e.g., "binance"
  string symbol = 2;            // e.g., "btc_usdt" (normalized)
  repeated OrderBookLevel bids = 3; // List of bid levels (price, quantity)
  repeated OrderBookLevel asks = 4; // List of ask levels (price, quantity)
  google.protobuf.Timestamp timestamp = 5; // Timestamp of the update
  bool is_snapshot = 6;         // True if this is a full order book snapshot
  int64 sequence_number = 7;    // Sequence number for handling updates
}

message OrderBookLevel {
  string price = 1;             // Price level (string)
  string quantity = 2;          // Quantity at this level (string)
}

message StreamMarketDataResponse {
  // Currently empty, as the server streams data back only if needed
  // (e.g., acknowledgment of connection).
  // For a client streaming RPC, the response is sent once at the end.
  // If real-time server status updates were needed, this would be a stream response.
}


// --- Messages and RPC for Order Execution ---

message OrderRequest {
  string client_order_id = 1;   // Unique ID generated by the client (Strategy Engine)
  string exchange = 2;          // Target exchange for the order
  string symbol = 3;            // Trading pair symbol
  OrderSide side = 4;           // BUY or SELL
  OrderType type = 5;           // MARKET or LIMIT, etc.
  string quantity = 6;          // Amount to buy/sell (string for precision)
  string price = 7;             // Price for LIMIT orders (string, ignored for MARKET)
  // Add other parameters like time_in_force, stop_price, etc.
}

message OrderResponse {
  string client_order_id = 1;   // The client_order_id from the request
  string exchange_order_id = 2; // The order ID assigned by the exchange
  OrderStatus status = 3;       // Current status of the order
  string message = 4;           // Optional message (e.g., rejection reason)
  google.protobuf.Timestamp timestamp = 5; // Timestamp of the response
  // Add filled quantity, average fill price, etc.
}

message OrderUpdateRequest {
  // Define criteria for updates if not subscribing to all orders
  // Leaving empty subscribes to all orders originating from this strategy engine instance
}

message OrderUpdate {
  string client_order_id = 1;
  string exchange_order_id = 2;
  string symbol = 3;
  OrderStatus status = 4;
  string message = 5;
  google.protobuf.Timestamp timestamp = 6;
  string quantity = 7; // Total quantity of the order
  string cumulative_filled_quantity = 8; // Total quantity filled so far
  string latest_fill_price = 9; // Price of the latest fill (if status is PARTIALLY_FILLED or FILLED)
  // Add other relevant fields (e.g., fees, trade_id for fill)
}